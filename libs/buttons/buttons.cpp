#include "pxt.h"

namespace pxt {
//%
Button *getButtonByPin(int pin, int flags) {
    auto cpid = DEVICE_ID_FIRST_BUTTON + pin;
    auto btn = (Button *)lookupComponent(cpid);
    if (btn == NULL) {
        auto pull = PullNone;
        if ((flags & 0xf0) == 0x10)
            pull = PullDown;
        else if ((flags & 0xf0) == 0x20)
            pull = PullUp;
        else if ((flags & 0xf0) == 0x20)
            pull = PullNone;
        else
            target_panic(42);
        btn = new Button(*lookupPin(pin), cpid, DEVICE_BUTTON_ALL_EVENTS,
                         (ButtonPolarity)(flags & 0xf), pull);
    }
    return btn;
}

// This is for A, B, and AB
//%
AbstractButton *getButton(int id) {
    int pa = getConfig(CFG_PIN_BTN_A);
    int pb = getConfig(CFG_PIN_BTN_B);
    int flags = getConfig(CFG_DEFAULT_BUTTON_MODE, BUTTON_ACTIVE_LOW_PULL_UP);
    if (id == 0)
        return getButtonByPin(pa, flags);
    else if (id == 1)
        return getButtonByPin(pb, flags);
    else if (id == 2)
        return getMultiButton(DEVICE_ID_BUTTON_AB, pa, pb, flags);
    else {
        target_panic(42);
        return NULL;
    }
}

//%
MultiButton *getMultiButton(int id, int pinA, int pinB, int flags) {
    auto btn = (MultiButton *)lookupComponent(id);
    if (btn == NULL) {
        auto bA = getButtonByPin(pinA, flags);
        auto bB = getButtonByPin(pinB, flags);
        btn = new codal::MultiButton(bA->id, bB->id, id);

        // A user has registered to receive events from the buttonAB multibutton.
        // Disable click events from being generated by ButtonA and ButtonB, and defer the
        // control of this to the multibutton handler.
        //
        // This way, buttons look independent unless a buttonAB is requested, at which
        // point button A+B clicks can be correclty handled without breaking
        // causal ordering.
        bA->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);
        bB->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);
        btn->setEventConfiguration(DEVICE_BUTTON_ALL_EVENTS);
    }
    return btn;
}
}

//% noRefCounting fixedInstances
namespace ButtonMethods {
/**
 * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...
 * @param button the button that needs to be clicked or used
 * @param event the kind of button gesture that needs to be detected
 * @param body code to run when the event is raised
 */
//% help=input/button/on-event
//% blockId=buttonEvent block="on %button|%event"
//% parts="buttonpair"
//% blockNamespace=input
//% button.fieldEditor="gridpicker"
//% button.fieldOptions.width=220
//% button.fieldOptions.columns=3
//% weight=96 blockGap=8
void onEvent(Button_ button, ButtonEvent ev, Action body) {
    registerWithDal(button->id, (int)ev, body);
}

/**
 * Check if a button is pressed or not.
 * @param button the button to query the request
 */
//% help=input/button/is-pressed
//% block="%button|is pressed"
//% blockId=buttonIsPressed
//% parts="buttonpair"
//% blockNamespace=input
//% button.fieldEditor="gridpicker"
//% button.fieldOptions.width=220
//% button.fieldOptions.columns=3
//% weight=50 blockGap=8
bool isPressed(Button_ button) {
    return button->isPressed();
}

/**
 * See if the button was pressed again since the last time you checked.
 * @param button the button to query the request
 */
//% help=input/button/was-pressed
//% block="%button|was pressed"
//% blockId=buttonWasPressed
//% parts="buttonpair"
//% blockNamespace=input
//% button.fieldEditor="gridpicker"
//% button.fieldOptions.width=220
//% button.fieldOptions.columns=3
//% group="More" weight=46 blockGap=8
bool wasPressed(Button_ button) {
    return button->wasPressed();
}
}
